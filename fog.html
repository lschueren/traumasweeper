<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trauma Sweeper</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: 'Arial', sans-serif;
            flex-direction: column;
            gap: 20px;
        }

        h1 {
            color: #333;
            font-size: 2em;
        }

        #game-info {
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin-bottom: 10px;
        }

        #bomb-counter, #level-counter {
            font-size: 1.5em;
            font-weight: bold;
            color: #555;
        }

        canvas {
            border: 2px solid #333;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>

    <div id="game-info">
        <h1 id="level-counter">Level: 1</h1>
        <h1 id="bomb-counter">Traumas: 11</h1>
    </div>
    <canvas id="myCanvas" width="800" height="600"></canvas>
    <p>arrow keys to move</p>
    <p>avoid the traumas! survive until they disappear</p>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const bombCounterDisplay = document.getElementById('bomb-counter');
        const levelCounterDisplay = document.getElementById('level-counter');

        // Create an off-screen canvas to act as the "fog of war" layer
        const fogCanvas = document.createElement('canvas');
        const fogCtx = fogCanvas.getContext('2d');
        fogCanvas.width = canvas.width;
        fogCanvas.height = canvas.height;

        // Initially fill the fog canvas with black
        fogCtx.fillStyle = 'black';
        fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);

        // Red Circle properties (controlled by user)
        const redCircle = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 10,
            color: 'red',
            dx: 0,
            dy: 0,
            health: 100,
            maxHealth: 100,
            isInvincible: false,
            flashTimer: 0
        };
        const redCircleSpeed = 4;
        let clearingRadius = 25; // Define a consistent clearing radius for movement
        let currentLevel = 1;

        // Define bomb colors
        const bombColors = ['blue', 'purple', 'green', 'orange', 'lime', 'magenta', 'cyan', 'yellow', 'gray', 'pink', 'teal'];

        // Bomb properties (moving by itself)
        const bombs = [];
        function createBombs() {
            bombs.length = 0; // Clear the array
            for (let i = 0; i < 11; i++) {
                let bombX, bombY;
                do {
                    bombX = Math.random() * canvas.width;
                    bombY = Math.random() * canvas.height;
                } while (Math.hypot(bombX - redCircle.x, bombY - redCircle.y) < 50); // Ensure a starting distance of at least 50px

                bombs.push({
                    x: bombX,
                    y: bombY,
                    radius: Math.random() * 30 + 24, // Increased size range (24 to 54)
                    color: bombColors[i], // Assign a different color
                    dx: (Math.random() * 4 - 2) * (Math.random() * 0.5 + 0.5),
                    dy: (Math.random() * 4 - 2) * (Math.random() * 0.5 + 0.5),
                    isRevealed: false,
                    isHit: false,
                    hitTimer: 0,
                    originalDx: 0,
                    originalDy: 0
                });
            }
        }
        createBombs();

        let keys = {};
        let animationFrame = 0;
        let gameOver = false;
        let levelUp = false;
        let levelUpTimer = 0;

        document.addEventListener('keydown', (e) => {
            if (e.repeat || gameOver || levelUp) return;
            keys[e.key] = true;
            updateRedCircleVelocity();
        });

        document.addEventListener('keyup', (e) => {
            if (gameOver || levelUp) return;
            keys[e.key] = false;
            updateRedCircleVelocity();
        });
        
        function updateRedCircleVelocity() {
            redCircle.dx = 0;
            redCircle.dy = 0;

            if (keys['ArrowRight']) {
                redCircle.dx = redCircleSpeed;
            } else if (keys['ArrowLeft']) {
                redCircle.dx = -redCircleSpeed;
            }

            if (keys['ArrowDown']) {
                redCircle.dy = redCircleSpeed;
            } else if (keys['ArrowUp']) {
                redCircle.dy = -redCircleSpeed;
            }
        }

        function clearFogAtRedCircle() {
            fogCtx.globalCompositeOperation = 'destination-out';
            fogCtx.beginPath();
            fogCtx.arc(redCircle.x, redCircle.y, clearingRadius, 0, Math.PI * 2, false);
            fogCtx.fillStyle = 'black';
            fogCtx.fill();
            fogCtx.closePath();
            fogCtx.globalCompositeOperation = 'source-over';
        }
        
        function drawBomb(x, y, color, isRevealed, radius, isHit, hitTimer) {
            ctx.save();
            ctx.translate(x, y);

            // Flash the bomb if it is hit and the timer is active
            if (isHit && hitTimer % 10 < 5) {
                // Do not draw the bomb
            } else {
                const numSpikes = 8;
                const outerRadius = radius;
                const innerRadius = radius * 0.6;
                const angleStep = (Math.PI * 2) / numSpikes;

                ctx.beginPath();
                for (let i = 0; i < numSpikes; i++) {
                    const outerAngle = i * angleStep;
                    const innerAngle = outerAngle + angleStep / 2;
                    
                    const outerX = outerRadius * Math.cos(outerAngle);
                    const outerY = outerRadius * Math.sin(outerAngle);
                    const innerX = innerRadius * Math.cos(innerAngle);
                    const innerY = innerRadius * Math.sin(innerAngle);

                    if (i === 0) {
                        ctx.moveTo(outerX, outerY);
                    } else {
                        ctx.lineTo(outerX, outerY);
                    }
                    ctx.lineTo(innerX, innerY);
                }
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();

                if (isRevealed) {
                    const eyeYOffset = -2;
                    ctx.fillStyle = 'white';
                    if (animationFrame === 0) {
                        ctx.fillRect(-3, eyeYOffset, 2, 2);
                        ctx.fillRect(1, eyeYOffset, 2, 2);
                    } else {
                        ctx.fillRect(-3, eyeYOffset + 1, 2, 2);
                        ctx.fillRect(1, eyeYOffset + 1, 2, 2);
                    }

                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(5, -12);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        function checkCollisions() {
            if (redCircle.isInvincible) return;

            for (const bomb of bombs) {
                const distance = Math.hypot(bomb.x - redCircle.x, bomb.y - redCircle.y);
                if (distance < bomb.radius + redCircle.radius) {
                    redCircle.health -= 5;
                    redCircle.isInvincible = true;
                    redCircle.flashTimer = 0;
                    if (redCircle.health <= 0) {
                        gameOver = true;
                    }

                    // Bomb hit behavior
                    if (!bomb.isHit) {
                        bomb.isHit = true;
                        bomb.hitTimer = 0;
                        bomb.originalDx = bomb.dx;
                        bomb.originalDy = bomb.dy;
                        bomb.dx = 0;
                        bomb.dy = 0;
                    }
                }
            }
        }

        function drawHealthBar() {
            const barWidth = 150;
            const barHeight = 15;
            const x = canvas.width - barWidth - 10;
            const y = 10;
            
            ctx.fillStyle = '#ccc';
            ctx.fillRect(x, y, barWidth, barHeight);

            const healthWidth = (redCircle.health / redCircle.maxHealth) * barWidth;
            ctx.fillStyle = 'red';
            ctx.fillRect(x, y, healthWidth, barHeight);

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, barWidth, barHeight);
        }

        function resetGame() {
            redCircle.x = canvas.width / 2;
            redCircle.y = canvas.height / 2;
            redCircle.dx = 0;
            redCircle.dy = 0;
            redCircle.health = 100;
            redCircle.isInvincible = false;
            redCircle.flashTimer = 0;
            
            fogCtx.fillStyle = 'black';
            fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
            
            createBombs();
            
            gameOver = false;
            levelUp = false;
            levelCounterDisplay.textContent = `Level: ${currentLevel}`;
            bombCounterDisplay.textContent = `Traumas: ${bombs.length}`;
            requestAnimationFrame(draw);
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 30);

            // Draw the "Play Again" button
            const buttonWidth = 150;
            const buttonHeight = 40;
            const buttonX = canvas.width / 2 - buttonWidth / 2;
            const buttonY = canvas.height / 2 + 10;

            ctx.fillStyle = 'rgba(0, 128, 0, 0.8)';
            ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('Play Again', canvas.width / 2, canvas.height / 2 + 35);
        }
        
        function drawLevelUp() {
            if (levelUpTimer % 20 < 10) { // Flashes on and off
                ctx.fillStyle = 'white';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL UP!', canvas.width / 2, canvas.height / 2);
            }
            levelUpTimer++;
        }

        canvas.addEventListener('click', (e) => {
            if (gameOver) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const buttonX = canvas.width / 2 - 75;
                const buttonY = canvas.height / 2 + 10;
                
                if (mouseX >= buttonX && mouseX <= buttonX + 150 && mouseY >= buttonY && mouseY <= buttonY + 40) {
                    clearingRadius = 25; // Reset clearing radius for a new game
                    currentLevel = 1;
                    resetGame();
                }
            }
        });

        function draw() {
            if (gameOver) {
                drawGameOver();
                return;
            }

            // Check if all bombs are gone to trigger level up
            if (bombs.length === 0 && !levelUp) {
                levelUp = true;
                levelUpTimer = 0;
                currentLevel++;
            }

            if (levelUp) {
                drawLevelUp();
                if (levelUpTimer > 120) { // 2 seconds of flashing
                    clearingRadius *= 1.2; // Increase clearing radius by 20%
                    resetGame();
                }
                requestAnimationFrame(draw);
                return;
            }

            animationFrame = (animationFrame + 1) % 2;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const remainingBombs = [];
            for (const bomb of bombs) {
                if (bomb.radius > 10) {
                    drawBomb(bomb.x, bomb.y, bomb.color, bomb.isRevealed, bomb.radius, bomb.isHit, bomb.hitTimer);
                    remainingBombs.push(bomb);
                }
            }
            bombs.length = 0; 
            bombs.push(...remainingBombs);
            bombCounterDisplay.textContent = `Traumas: ${bombs.length}`;

            for (const bomb of bombs) {
                if (!bomb.isRevealed) {
                    const imageData = fogCtx.getImageData(bomb.x, bomb.y, 1, 1).data;
                    if (imageData[3] === 0) {
                        bomb.isRevealed = true;
                    }
                }
            }

            ctx.drawImage(fogCanvas, 0, 0);

            // Flash the red dot if it is invincible
            if (redCircle.isInvincible && redCircle.flashTimer % 10 < 5) {
                // Do not draw the dot
            } else {
                ctx.beginPath();
                ctx.arc(redCircle.x, redCircle.y, redCircle.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = redCircle.color;
                ctx.fill();
                ctx.closePath();
            }
            
            const revealedBombs = bombs.filter(bomb => bomb.isRevealed);
            for (let i = 0; i < revealedBombs.length; i++) {
                const bomb = revealedBombs[i];
                const angle = Math.atan2(bomb.y - redCircle.y, bomb.x - redCircle.x);
                const distanceToBomb = Math.hypot(bomb.x - redCircle.x, bomb.y - redCircle.y);
                
                const minRadius = 1;
                const maxRadius = 2;
                const maxDistance = Math.hypot(canvas.width, canvas.height);

                const normalizedDistance = Math.min(1, distanceToBomb / (maxDistance * 0.5));
                const indicatorRadius = maxRadius - (normalizedDistance * (maxRadius - minRadius));

                const ringRadius = redCircle.radius + 15;

                const indicatorX = redCircle.x + ringRadius * Math.cos(angle);
                const indicatorY = redCircle.y + ringRadius * Math.sin(angle);

                ctx.beginPath();
                ctx.arc(indicatorX, indicatorY, indicatorRadius, 0, Math.PI * 2, false);
                ctx.fillStyle = bomb.color;
                ctx.fill();
            }

            redCircle.x += redCircle.dx;
            redCircle.y += redCircle.dy;

            clearFogAtRedCircle();
            checkCollisions();
            drawHealthBar();
            
            // Manage invincibility time
            if (redCircle.isInvincible) {
                redCircle.flashTimer++;
                if (redCircle.flashTimer > 60) { // 60 frames = 1 second
                    redCircle.isInvincible = false;
                }
            }

            for (const bomb of bombs) {
                // Manage bomb hit timer and size increase
                if (bomb.isHit) {
                    bomb.hitTimer++;
                    if (bomb.hitTimer > 120) { // 120 frames = 2 seconds
                        bomb.isHit = false;
                        bomb.radius = bomb.radius * 1.2; // Increase size by 20%
                        bomb.dx = bomb.originalDx; // Resume movement
                        bomb.dy = bomb.originalDy;
                    }
                } else {
                    // Shrink bombs that are not hit
                    if (bomb.radius > 10) {
                         bomb.radius -= 0.008; // Increased size decrease factor from 0.004 to 0.008
                    }
                }

                bomb.x += bomb.dx;
                bomb.y += bomb.dy;

                if (bomb.x + bomb.radius > canvas.width || bomb.x - bomb.radius < 0) {
                    bomb.dx = -bomb.dx;
                }
                if (bomb.y + bomb.radius > canvas.height || bomb.y - bomb.radius < 0) {
                    bomb.dy = -bomb.dy;
                }
            }

            if (redCircle.x + redCircle.radius > canvas.width) {
                redCircle.x = canvas.width - redCircle.radius;
            } else if (redCircle.x - redCircle.radius < 0) {
                redCircle.x = redCircle.radius;
            }
            if (redCircle.y + redCircle.radius > canvas.height) {
                redCircle.y = canvas.height - redCircle.radius;
            } else if (redCircle.y - redCircle.radius < 0) {
                redCircle.y = redCircle.radius;
            }

            requestAnimationFrame(draw);
        }

        window.onload = function() {
            draw();
        };
    </script>
</body>
</html>
